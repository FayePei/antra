1.Why are closures useful in JavaScript? Give an example use case.
ans:
Closures can be used to create private variables that cannot be accessed from outside the function scope.
function createCounter() {
  let count = 0; // This variable is private and only accessible within the createCounter function

  return {
    increment: function() {
      count++;
      return count;
    },
    decrement: function() {
      count--;
      return count;
    },
    getCount: function() {
      return count;
    }
  };
}

const counter = createCounter();

console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.decrement()); // 1
console.log(counter.getCount());  // 1

// The count variable is not directly accessible
// console.log(counter.count);    // undefined


2.When should you choose to use “let” or “const”
let and const are used to declare variables with block scope.
const: Use const when you want to declare a constant reference to a value. The reference cannot be reassigned, although the value it points to (if it's an object or array) can still be mutated.
let: Use let when you need to declare a variable that can be reassigned. 


3.Give an example of a common mistake related to hoisting and explain how to fix it.
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i); // 3, 3, 3
  }, 1000);
}

Here, because var is function-scoped, the variable i is shared across all iterations of the loop, and by the time the setTimeout callbacks are executed, the value of i is 3.

Fix: Use let to Create a Block Scope
Using let creates a new block-scoped variable for each iteration of the loop:
for (let i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i); // 0, 1, 2
  }, 1000);
}

4.What will the outcome of each console.log() be after the function calls? Why?
const arr = [1, 2];
function foo1(arg) {
  arg.push(3);
}
foo1(arr);
console.log(arr);

function foo2(arg) {
  arg = [1, 2, 3, 4];
}
foo2(arr);
console.log(arr);

function foo3(arg) {
  let b = arg;
  b.push(3);
}
foo3(arr);
console.log(arr);

function foo4(arg) {
  let b = arg;
  b = [1, 2, 3, 4];
}
foo4(arr);
console.log(arr);

ans:foo1(arr): [1, 2, 3]
   foo2(arr): [1, 2, 3]
   foo3(arr): [1, 2, 3, 3]
foo3 takes an argument arg and assigns it to a local variable b.
b is a reference to the same array as arg, so b.push(3) modifies the original array arr.
   foo4(arr): [1, 2, 3, 3]
foo4 takes an argument arg and assigns it to a local variable b.
Then it assigns a new array [1, 2, 3, 4] to b.
This does not affect the original array arr because the assignment b = [1, 2, 3, 4] changes only the local reference b, not the original array.
